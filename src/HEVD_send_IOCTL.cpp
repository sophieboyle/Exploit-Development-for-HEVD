#include <iostream>
#include <windows.h>

// IOCTL Definitions from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS               CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_NON_PAGED_POOL_OVERFLOW         CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_TYPE_CONFUSION                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW                CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80A, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80B, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80C, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_DOUBLE_FETCH                    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80D, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80E, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_MEMORY_DISCLOSURE               CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80F, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_PAGED_POOL_SESSION              CTL_CODE(FILE_DEVICE_UNKNOWN, 0x810, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_WRITE_NULL                      CTL_CODE(FILE_DEVICE_UNKNOWN, 0x811, METHOD_NEITHER, FILE_ANY_ACCESS)

DWORD ioctls[] = {
                    HACKSYS_EVD_IOCTL_STACK_OVERFLOW,
                    HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS,
                    HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
                    HACKSYS_EVD_IOCTL_NON_PAGED_POOL_OVERFLOW,
                    HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                    HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                    HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                    HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT,
                    HACKSYS_EVD_IOCTL_TYPE_CONFUSION,
                    HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW,
                    HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE,
                    HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,
                    HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE,
                    HACKSYS_EVD_IOCTL_DOUBLE_FETCH,
                    HACKSYS_EVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS,
                    HACKSYS_EVD_IOCTL_MEMORY_DISCLOSURE,
                    HACKSYS_EVD_IOCTL_PAGED_POOL_SESSION,
                    HACKSYS_EVD_IOCTL_WRITE_NULL,

};

DWORD get_ioctl(int index){
    if (index >= sizeof(ioctls) / sizeof(*ioctls)){
        return -1;
    }
    return ioctls[index];
}

int main(int argc, char* argv[]){
    // Print usage if not enough args
    if (argc < 2){
        std::cerr << "Usage: " << argv[0] << "IOCTL_index buffSize" << std::endl;
    }

    char devName[] = "\\\\.\\HackSysExtremeVulnerableDriver";
    DWORD inBuffSize = std::stoi(argv[2]);

    // Get a handle to the driver
    HANDLE dev = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 
                                NULL, NULL, OPEN_EXISTING, NULL, NULL);

    // Handle failure
    if (dev == INVALID_HANDLE_VALUE){
        std::cerr << "Could not get device handle" << std::endl;
        return 1;
    }

    // Get the IOCTL defined by cmdline args
    int ioctlIndex = std::stoi(argv[1]);
    DWORD ioctl = get_ioctl(ioctlIndex);

    // Check if ioctl fetched correctly
    if (ioctl == -1){
        std::cerr << "Incorrect ioctl index" << std::endl;
    }

    // Set up input buffer
    BYTE* inBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, inBuffSize);
    RtlFillMemory(inBuffer, inBuffSize, 'A');

    DWORD bytesRet = 0;

    // Send the IOCTL
    std::cout << "Sending IOCTL\n";
    BOOL status = DeviceIoControl(dev, ioctl, inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Release input buffer and close device
    HeapFree(GetProcessHeap(), 0, (LPVOID)inBuffer);
    CloseHandle(dev);
    return 0;
}
